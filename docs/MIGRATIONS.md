# Database Migration Guide

## Overview

This project uses a **split migration strategy** where authentication and business logic tables are managed by different systems:

| Component | Technology | Manages |
|-----------|-----------|---------|
| **Frontend** | Drizzle ORM + Better Auth | Auth tables: `users`, `accounts`, `sessions`, `verification`, `jwks` |
| **Backend** | Entity Framework Core | Business tables: `foods`, `recipes`, `workouts`, `goals`, `households`, etc. |

Both components share the same PostgreSQL database but manage different tables.

## Migration Order - CRITICAL

**⚠️ Migrations MUST run in this specific order:**

```
1. Frontend (Drizzle) → Creates auth tables (especially 'users')
2. Backend (EF Core) → Creates business tables with foreign keys to 'users'
```

### Why This Order?

- Backend tables have foreign keys referencing the `users` table
- The `users` table must exist **before** backend migrations run
- Frontend (Better Auth) creates and owns the `users` table
- Backend migrations create foreign keys to `users` but don't create the table itself

### Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                     PostgreSQL Database                      │
│                                                              │
│  ┌──────────────────────┐      ┌─────────────────────────┐  │
│  │   Auth Tables        │      │   Business Tables       │  │
│  │   (Frontend/Drizzle) │      │   (Backend/EF Core)     │  │
│  │                      │      │                         │  │
│  │  • users ◄───────────┼──────┼──┐  • foods            │  │
│  │  • accounts          │  FK  │  ├──┤ recipes          │  │
│  │  • sessions          │      │  │  • workouts         │  │
│  │  • verification      │      │  │  • goals            │  │
│  │  • jwks              │      │  │  • households       │  │
│  └──────────────────────┘      │  │  • meal_plans       │  │
│                                │  │  • etc.             │  │
│                                │  └─────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

**⚠️ Known Architectural Weakness**: The current design has a circular dependency. Backend tables depend on the `users` table via foreign keys, but the `users` table is owned by the frontend. This requires careful ordering of migrations. In the future, consider:
- Removing foreign keys from backend tables to `users` and using application-level validation
- Having the backend own all tables with the frontend using API calls for auth
- Using a separate auth database

---

## Frontend Migration (Drizzle) - RUN FIRST

### Step 1: Configure Environment

Ensure these are set in your `.env` or `docker-compose.yml`:

```yaml
frontend:
  environment:
    - RUN_DB_MIGRATIONS=true
    - DATABASE_URL=postgres://admin:password@host:5432/mizan
```

### Step 2: Start Frontend Container

```bash
docker-compose up -d frontend
```

The container automatically:
1. Runs `drizzle-kit migrate` (if `RUN_DB_MIGRATIONS=true`)
2. Creates auth tables: `users`, `accounts`, `sessions`, `verification`, `jwks`
3. Starts the Next.js server

### Step 3: Verify Auth Tables Created

```bash
docker exec -it postgresql-db psql -U admin -d mizan -c "\\dt users accounts sessions verification jwks"
```

Expected output: All 5 auth tables should exist.

### Frontend Schema Definition

Auth tables are defined in `frontend/db/schema.ts`:

```typescript
// BetterAuth Core Tables
export const users = pgTable("users", { ... });
export const accounts = pgTable("accounts", { ... });
export const sessions = pgTable("sessions", { ... });
export const verification = pgTable("verification", { ... });
export const jwks = pgTable("jwks", { ... });
```

**Only these 5 tables are managed by Drizzle.** All other tables are backend-managed.

### Frontend Migration Files

Located in `frontend/db/migrations/`:
- Generated by `drizzle-kit generate`
- Applied by `drizzle-kit migrate` on container startup
- Should only contain the 5 auth tables

### Regenerating Frontend Migrations (Advanced)

**⚠️ Only do this if you need to modify auth table structure:**

```bash
cd frontend
rm -rf db/migrations/*
bunx drizzle-kit generate
```

---

## Backend Migration (EF Core) - RUN SECOND

### Prerequisites

You need the .NET SDK installed locally or access to the backend container.

### Step 1: Generate Migration

Since old migrations were removed, generate a fresh initial migration:

```bash
cd backend/Mizan.Infrastructure

dotnet ef migrations add InitialCreate \
  --startup-project ../Mizan.Api \
  --project . \
  --output-dir Data/Migrations \
  --context MizanDbContext
```

**Note**: The `users` table is automatically excluded via:
```csharp
entity.Metadata.SetIsTableExcludedFromMigrations(true);
```

This is set in `MizanDbContext.cs` and tells EF Core to skip the `users` table in migrations.

### Step 2: Verify Migration (Optional)

Check the generated file to confirm `users` table is NOT created:

```bash
grep 'name: "users"' Data/Migrations/*_InitialCreate.cs
```

Expected: Should only show foreign key references, NOT table creation.

Correct output example:
```
name: "FK_foods_users_created_by_user_id"
name: "FK_recipes_users_user_id"
```

NOT:
```
name: "users"  # This would be table creation - should NOT appear
```

### Step 3: Apply Migration

**Option A: Development Mode (Auto-migrate)**

```bash
# Run backend in Development environment
ASPNETCORE_ENVIRONMENT=Development dotnet run --project ../Mizan.Api
```

The backend will automatically apply migrations on startup.

**Option B: Production Mode (Manual migration)**

In Production, migrations do NOT run automatically. You need to:

```bash
# Option 1: Use EF Core CLI
dotnet ef database update \
  --startup-project ../Mizan.Api \
  --project . \
  --context MizanDbContext

# Option 2: Temporarily run in Development mode
docker-compose run --rm -e ASPNETCORE_ENVIRONMENT=Development backend
```

### How `SetIsTableExcludedFromMigrations` Works

In `backend/Mizan.Infrastructure/Data/MizanDbContext.cs`:

```csharp
modelBuilder.Entity<User>(entity =>
{
    entity.ToTable("users");
    entity.HasKey(e => e.Id);
    // ... other configuration ...
    
    // This tells EF Core to skip this table in migrations
    entity.Metadata.SetIsTableExcludedFromMigrations(true);
});
```

**What this does:**
- ✅ Excludes `users` table from `CreateTable` operations
- ✅ Excludes `users` table from `DropTable` operations
- ✅ Still allows foreign key references TO `users` table
- ✅ Still allows queries on `users` table (it's mapped but not migrated)

**Requirements:**
- EF Core 6.0+
- Must be set in `OnModelCreating` method
- Works for both code-first and database-first scenarios

---

## Troubleshooting

### Error: "relation 'users' does not exist"

**Cause**: Backend migrations ran before frontend created the `users` table.

**Solution**:
1. Stop all containers: `docker-compose down`
2. If database is empty, wipe it: 
   ```sql
   DROP SCHEMA public CASCADE;
   CREATE SCHEMA public;
   GRANT ALL ON SCHEMA public TO admin;
   ```
3. Start frontend FIRST: `docker-compose up -d frontend`
4. Wait for frontend to be ready (check logs)
5. Start backend SECOND: `docker-compose up -d backend`

### Error: "relation 'users' already exists"

**Cause**: EF Core is trying to create the `users` table despite exclusion.

**Solution**:
1. Verify exclusion is configured:
   ```csharp
   entity.Metadata.SetIsTableExcludedFromMigrations(true);
   ```
2. Regenerate migration:
   ```bash
   rm -rf backend/Mizan.Infrastructure/Data/Migrations/*
   cd backend/Mizan.Infrastructure
   dotnet ef migrations add InitialCreate --startup-project ../Mizan.Api
   ```
3. Check generated file doesn't contain `CreateTable` for `users`

### Error: "Foreign key constraint violation"

**Cause**: Trying to insert data into backend tables with non-existent user IDs.

**Solution**: Ensure users exist in the `users` table before creating related data. The frontend auth system must be working first.

### Mixed Migration State

If migrations are in a bad state:

**Nuclear Option** (Only if database is empty or you can afford data loss):

```sql
-- Connect to PostgreSQL
docker exec -it postgresql-db psql -U admin -d mizan

-- Wipe everything
DROP SCHEMA public CASCADE;
CREATE SCHEMA public;
GRANT ALL ON SCHEMA public TO admin;
GRANT ALL ON SCHEMA public TO public;

-- Exit PostgreSQL
\q
```

Then restart in correct order:
```bash
docker-compose down
docker-compose up -d frontend  # Creates auth tables first
docker-compose up -d backend   # Creates business tables second
```

### Missing Tables After Deployment

**Frontend tables missing**:
- Check `RUN_DB_MIGRATIONS=true` is set
- Check `DATABASE_URL` is correct
- Check frontend logs: `docker-compose logs frontend | grep -i migration`

**Backend tables missing**:
- Check backend is running in Development mode (for auto-migrate)
- Or manually run: `dotnet ef database update`
- Check backend logs: `docker-compose logs backend | grep -i migration`

---

## Configuration Reference

### Frontend Environment Variables

| Variable | Required | Description |
|----------|----------|-------------|
| `RUN_DB_MIGRATIONS` | Yes | Set to `true` to run migrations on startup |
| `DATABASE_URL` | Yes | PostgreSQL connection string |

### Backend Environment Variables

| Variable | Required | Description |
|----------|----------|-------------|
| `ASPNETCORE_ENVIRONMENT` | Yes | Set to `Development` for auto-migrate, `Production` for manual |
| `ConnectionStrings__PostgreSQL` | Yes | PostgreSQL connection string |

### Docker Compose Example

```yaml
services:
  frontend:
    image: mizan-frontend:latest
    environment:
      - RUN_DB_MIGRATIONS=true
      - DATABASE_URL=postgres://admin:password@postgresql-db:5432/mizan
    depends_on:
      - backend  # Wait for backend health check
    
  backend:
    image: mizan-backend:latest
    environment:
      - ASPNETCORE_ENVIRONMENT=Development  # Auto-migrate in dev
      - ConnectionStrings__PostgreSQL=Host=postgresql-db;Database=mizan;Username=admin;Password=password
```

---

## Database Schema Summary

### Auth Tables (Frontend/Drizzle)

| Table | Purpose | Created By |
|-------|---------|------------|
| `users` | User accounts | Frontend |
| `accounts` | OAuth provider accounts | Frontend |
| `sessions` | User sessions | Frontend |
| `verification` | Email verification tokens | Frontend |
| `jwks` | JWT signing keys | Frontend |

### Business Tables (Backend/EF Core)

| Table | Purpose | Foreign Keys |
|-------|---------|--------------|
| `foods` | Food database | users (created_by) |
| `recipes` | User recipes | users, households |
| `recipe_ingredients` | Recipe ingredients | recipes, foods |
| `workouts` | User workouts | users |
| `exercises` | Exercise library | users (created_by) |
| `user_goals` | User goals | users |
| `households` | Households/organizations | users (created_by) |
| `meal_plans` | Meal plans | users, households |
| `shopping_lists` | Shopping lists | users, households |
| ... | ... | ... |

### Migration History Tables

| Table | Purpose | Managed By |
|-------|---------|------------|
| `__EFMigrationsHistory` | EF Core migration tracking | Backend |
| `drizzle.__drizzle_migrations` | Drizzle migration tracking | Frontend |

---

## Best Practices

1. **Always run migrations in order**: Frontend first, Backend second
2. **Never skip the order**: Backend FKs will fail if users table doesn't exist
3. **Test migrations locally** before deploying to production
4. **Backup database** before running migrations in production
5. **Use Development mode** for initial setup, then switch to Production
6. **Monitor logs** during migration to catch issues early
7. **Keep migrations clean**: Delete and regenerate if they get messy

## See Also

- [Frontend README](../frontend/README.md) - Frontend-specific documentation
- [Backend README](../backend/README.md) - Backend-specific documentation
- [Drizzle Documentation](https://orm.drizzle.team/docs/overview) - Drizzle ORM docs
- [EF Core Documentation](https://docs.microsoft.com/en-us/ef/core/) - Entity Framework docs
